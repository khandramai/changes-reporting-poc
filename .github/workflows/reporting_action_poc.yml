name: Reporting Action PoC

on:
  push:
    branches: ["**"]
    paths:
      - "ramls/*.json"
  pull_request:
    branches: ["**"]
    paths:
      - "ramls/*.json"
  release:
    types: [created, published]
  workflow_dispatch:
    inputs:
      base:
        description: "Optional base ref (tag/commit)"
        required: false
      head:
        description: "Optional head ref (tag/commit)"
        required: false

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  diff:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (full history incl. tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine BASE/HEAD
        id: refs
        shell: bash
        run: |
          set -Eeuo pipefail
          BASE_IN="${{ github.event.inputs.base || '' }}"
          HEAD_IN="${{ github.event.inputs.head || '' }}"

          case "${{ github.event_name }}" in
            push)
              BASE="${BASE_IN:-${{ github.event.before }}}"
              HEAD="${HEAD_IN:-${GITHUB_SHA}}"
              ;;
            pull_request)
              BASE="${BASE_IN:-${{ github.event.pull_request.base.sha }}}"
              HEAD="${HEAD_IN:-${{ github.event.pull_request.head.sha }}}"
              ;;
            release)
              CUR_TAG="${{ github.event.release.tag_name }}"
              HEAD="${HEAD_IN:-$CUR_TAG}"
              PREV_TAG="$(git tag --sort=-creatordate | grep -A1 "^${CUR_TAG}$" | tail -n1 || true)"
              [[ -z "$PREV_TAG" ]] && PREV_TAG="$(git tag --sort=creatordate | head -n1 || true)"
              [[ -z "$PREV_TAG" ]] && PREV_TAG="$(git rev-list --max-parents=0 HEAD | tail -n1)"
              BASE="${BASE_IN:-$PREV_TAG}"
              ;;
            workflow_dispatch)
              HEAD="${HEAD_IN:-${GITHUB_SHA}}"
              if [[ -n "$BASE_IN" ]]; then
                BASE="$BASE_IN"
              else
                BASE="$(git rev-parse HEAD~1 2>/dev/null || git rev-list --max-parents=0 HEAD | tail -n1)"
              fi
              ;;
            *)
              HEAD="${HEAD_IN:-${GITHUB_SHA}}"
              BASE="${BASE_IN:-$(git rev-parse HEAD~1 2>/dev/null || git rev-list --max-parents=0 HEAD | tail -n1)}"
              ;;
          esac

          git rev-parse "$BASE" "$HEAD" >/dev/null
          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD" >> "$GITHUB_OUTPUT"

      - name: Install jq (quiet)
        run: sudo apt-get update -qq && sudo apt-get install -y -qq jq

      - name: Build report (summary only, refactored)
        shell: bash
        run: |
          set -Eeuo pipefail

          BASE="${{ steps.refs.outputs.base }}"
          HEAD="${{ steps.refs.outputs.head }}"
          MAX_LINES=500

          # Helpers
          mkfile() { mktemp -t "$1.XXXXXX"; }
          truncate_or_all() {  # $1=file
            local LINES
            LINES=$(wc -l < "$1" || echo 0)
            if (( LINES > MAX_LINES )); then
              head -n "$MAX_LINES" "$1"
              echo "_Output truncated to ${MAX_LINES} lines._"
            else
              cat "$1"
            fi
          }

          # Detect changes (top-level only)
          git -c diff.renames=true diff --name-status -M "$BASE" "$HEAD" -- ramls/*.json > /tmp/status.txt || true

          {
            echo "## JSON Schema Changes"
            echo
            echo "- Base: \`$BASE\`"
            echo "- Head: \`$HEAD\`"
            echo
          } >> "$GITHUB_STEP_SUMMARY"

          if [[ ! -s /tmp/status.txt ]]; then
            echo "_No JSON schema changes detected in \`ramls/\` (top-level)._ " >> "$GITHUB_STEP_SUMMARY"
            # create report.md before exiting (so PR comment step has content)
            cat "$GITHUB_STEP_SUMMARY" > report.md
            exit 0
          fi

          {
            echo "### Changed files"
            echo
            echo "| Status | File (HEAD) |"
            echo "|---|---|"
          } >> "$GITHUB_STEP_SUMMARY"

          # Read status lines into array (без mapfile)
          CHANGES=()
          while IFS= read -r LINE; do
            CHANGES+=("$LINE")
          done < /tmp/status.txt

          # Table rows with human-readable statuses
          for LINE in "${CHANGES[@]}"; do
            IFS=$'\t' read -r S A B <<< "$LINE"
            FILE="$A"
            [[ "$S" == R* ]] && FILE="$B"

            case "$S" in
              M)   STATUS="Modified" ;;
              A)   STATUS="Added" ;;
              D)   STATUS="Deleted" ;;
              R*)  PCT="${S#R}"; STATUS="Renamed (${PCT}%)" ;;
              C*)  PCT="${S#C}"; STATUS="Copied (${PCT}%)" ;;
              T)   STATUS="Type changed" ;;
              U)   STATUS="Unmerged" ;;
              X)   STATUS="Unknown" ;;
              B)   STATUS="Broken pairing" ;;
              *)   STATUS="$S" ;;
            esac

            echo "| $STATUS | \`$FILE\` |" >> "$GITHUB_STEP_SUMMARY"
          done

          {
            echo
            echo "### Diffs (normalized first, fallback to raw if empty)"
            echo
          } >> "$GITHUB_STEP_SUMMARY"

          for LINE in "${CHANGES[@]}"; do
            IFS=$'\t' read -r S A B <<< "$LINE"

            # Resolve paths for rename vs others
            BASE_PATH="$A"; HEAD_PATH="$A"; TITLE="$A"
            if [[ "$S" == R* ]]; then
              BASE_PATH="$A"; HEAD_PATH="$B"; TITLE="$B"
            fi

            echo "#### \`$TITLE\`" >> "$GITHUB_STEP_SUMMARY"

            # Extract contents (may be empty if add/delete)
            BASE_RAW="$(mkfile base_raw)"
            HEAD_RAW="$(mkfile head_raw)"
            git show "$BASE:$BASE_PATH" 2>/dev/null > "$BASE_RAW" || true
            git show "$HEAD:$HEAD_PATH" 2>/dev/null > "$HEAD_RAW" || true

            # Normalize via jq -S . (fallback to {} if invalid)
            BASE_NORM="$(mkfile base_json)"
            HEAD_NORM="$(mkfile head_json)"
            VALID_BASE=1; VALID_HEAD=1
            if ! jq -S . < "$BASE_RAW" > "$BASE_NORM" 2>/dev/null; then VALID_BASE=0; echo '{}' > "$BASE_NORM"; fi
            if ! jq -S . < "$HEAD_RAW" > "$HEAD_NORM" 2>/dev/null; then VALID_HEAD=0; echo '{}' > "$HEAD_NORM"; fi

            # 1) Try normalized (structural) diff
            NORM_DIFF="$(mkfile norm_diff)"
            if ! diff -u --label "$TITLE (base)" --label "$TITLE (head)" \
                   "$BASE_NORM" "$HEAD_NORM" > "$NORM_DIFF"; then
              echo '```diff' >> "$GITHUB_STEP_SUMMARY"
              truncate_or_all "$NORM_DIFF" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            else
              # 2) Fallback to raw textual diff (formatting-only or invalid JSON)
              [[ $VALID_BASE -eq 0 || $VALID_HEAD -eq 0 ]] && \
                echo "_Note: one of the versions is not valid JSON — raw diff only._" >> "$GITHUB_STEP_SUMMARY"
              echo "_No structural changes (after normalization)_" >> "$GITHUB_STEP_SUMMARY"
              echo >> "$GITHUB_STEP_SUMMARY"

              RAW_DIFF="$(mkfile raw_diff)"
              diff -u --label "$TITLE (base)" --label "$TITLE (head)" \
                   "$BASE_RAW" "$HEAD_RAW" > "$RAW_DIFF" || true

              echo "_Showing raw textual diff (formatting/whitespace changes may appear)_" >> "$GITHUB_STEP_SUMMARY"
              echo '```diff' >> "$GITHUB_STEP_SUMMARY"
              truncate_or_all "$RAW_DIFF" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            fi

            echo >> "$GITHUB_STEP_SUMMARY"
          done

          # create report.md with final summary when changes exist
          cat "$GITHUB_STEP_SUMMARY" > report.md

      - name: Ensure report exists
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          ls -l report.md || true
          test -s report.md || (echo "report.md is missing or empty" && exit 1)

      - name: Comment PR with report
        if: ${{ github.event_name == 'pull_request' }}
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: "Schema Changes Report"
          recreate: true
          path: report.md
