name: Reporting Action PoC

on:
  push:
    branches: ["**"]
    paths:
      - "ramls/*.json"
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches: ["**"]
    paths:
      - "ramls/*.json"
  release:
    types: [created, published]
  workflow_dispatch: {}
  workflow_call: {}

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  diff:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve called repo/ref
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          WF_REF="${{ github.workflow_ref }}"
          if [[ -n "$WF_REF" && "$WF_REF" == *"/.github/workflows/"* && "$WF_REF" == *"@"* ]]; then
            CALLED_REPO="${WF_REF%%/.github/workflows/*}"
            CALLED_REF="${WF_REF#*@}"
          else
            CALLED_REPO="${{ github.repository }}"
            CALLED_REF="${{ github.ref }}"
          fi
          echo "repo=$CALLED_REPO" >> "$GITHUB_OUTPUT"
          echo "ref=$CALLED_REF"   >> "$GITHUB_OUTPUT"

      - name: Checkout called workflow repo (full history)
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.meta.outputs.repo }}
          ref: ${{ steps.meta.outputs.ref }}
          fetch-depth: 0
          fetch-tags: false
          persist-credentials: true

      - name: Fetch all branches and tags
        shell: bash
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${{ github.token }}@github.com/${{ steps.meta.outputs.repo }}.git"
          git fetch --prune --force origin \
            "+refs/heads/*:refs/remotes/origin/*" \
            "+refs/tags/*:refs/tags/*"

      - name: Determine BASE/HEAD
        id: refs
        shell: bash
        run: |
          set -euo pipefail

          # Функция: взять последний и предпоследний теги по времени создания
          latest_two_tags() {
            git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags | sed -n '1p;2p'
          }

          case "${{ github.event_name }}" in
            push)
              BASE="${{ github.event.before }}"
              HEAD="${GITHUB_SHA}"
              ;;
            pull_request)
              BASE="${{ github.event.pull_request.base.sha }}"
              HEAD="${{ github.event.pull_request.head.sha }}"
              ;;
            release)
              CUR_TAG="${{ github.event.release.tag_name }}"
              HEAD="$CUR_TAG"
              PREV_TAG="$(git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags | awk -v cur="$CUR_TAG" 'f==1{print; exit} {if($0==cur) f=1} END{if(f!=1) exit 0}')" || true
              if [[ -z "${PREV_TAG:-}" ]]; then
                PREV_TAG="$(git for-each-ref --sort=creatordate --format '%(refname:short)' refs/tags | head -n1 || true)"
              fi
              if [[ -z "${PREV_TAG:-}" ]]; then
                echo "No previous tag found to compare with $CUR_TAG" >&2
                exit 1
              fi
              BASE="$PREV_TAG"
              ;;
            workflow_dispatch|workflow_call)
              mapfile -t TAGS < <(latest_two_tags)
              if (( ${#TAGS[@]} < 2 )); then
                echo "Need at least two tags in repo to generate report for workflow_dispatch/workflow_call." >&2
                echo "Found tags: ${TAGS[*]:-none}" >&2
                exit 1
              fi
              HEAD="${TAGS[0]}"
              BASE="${TAGS[1]}"
              ;;
            *)
              BASE="$(git rev-parse HEAD~1 2>/dev/null || git rev-list --max-parents=0 HEAD | tail -n1)"
              HEAD="$(git rev-parse HEAD)"
              ;;
          esac

          git rev-parse "$BASE" >/dev/null 2>&1 || { echo "Base ref not resolvable: $BASE" >&2; exit 1; }
          git rev-parse "$HEAD" >/dev/null 2>&1 || { echo "Head ref not resolvable: $HEAD" >&2; exit 1; }

          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD" >> "$GITHUB_OUTPUT"

      - name: Install jq
        run: sudo apt-get update -qq && sudo apt-get install -y -qq jq

      - name: Build report (summary only)
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ steps.refs.outputs.base }}"
          HEAD="${{ steps.refs.outputs.head }}"
          MAX_LINES=500

          mkfile() { mktemp -t "$1.XXXXXX"; }
          truncate_or_all() {
            local LINES
            LINES=$(wc -l < "$1" || echo 0)
            if (( LINES > MAX_LINES )); then
              head -n "$MAX_LINES" "$1"
              echo "_Output truncated to ${MAX_LINES} lines._"
            else
              cat "$1"
            fi
          }

          git -c diff.renames=true diff --name-status -M "$BASE" "$HEAD" -- ramls/*.json > /tmp/status.txt || true

          {
            echo "## JSON Schema Changes"
            echo
            echo "- Base: \`$BASE\`"
            echo "- Head: \`$HEAD\`"
            echo
          } >> "$GITHUB_STEP_SUMMARY"

          if [[ ! -s /tmp/status.txt ]]; then
            echo "_No JSON schema changes detected in \`ramls/\` (top-level)._ " >> "$GITHUB_STEP_SUMMARY"
            cat "$GITHUB_STEP_SUMMARY" > report.md
            exit 0
          fi

          {
            echo "### Changed files"
            echo
            echo "| Status | File (HEAD) |"
            echo "|---|---|"
          } >> "$GITHUB_STEP_SUMMARY"

          CHANGES=()
          while IFS= read -r LINE; do
            CHANGES+=("$LINE")
          done < /tmp/status.txt

          for LINE in "${CHANGES[@]}"; do
            IFS=$'\t' read -r S A B <<< "$LINE"
            FILE="$A"
            [[ "$S" == R* ]] && FILE="$B"
            case "$S" in
              M) STATUS="Modified" ;;
              A) STATUS="Added" ;;
              D) STATUS="Deleted" ;;
              R*) PCT="${S#R}"; STATUS="Renamed (${PCT}%)" ;;
              C*) PCT="${S#C}"; STATUS="Copied (${PCT}%)" ;;
              T) STATUS="Type changed" ;;
              U) STATUS="Unmerged" ;;
              X) STATUS="Unknown" ;;
              B) STATUS="Broken pairing" ;;
              *) STATUS="$S" ;;
            esac
            echo "| $STATUS | \`$FILE\` |" >> "$GITHUB_STEP_SUMMARY"
          done

          {
            echo
            echo "### Diffs (normalized first, fallback to raw if empty)"
            echo
          } >> "$GITHUB_STEP_SUMMARY"

          for LINE in "${CHANGES[@]}"; do
            IFS=$'\t' read -r S A B <<< "$LINE"
            BASE_PATH="$A"; HEAD_PATH="$A"; TITLE="$A"
            if [[ "$S" == R* ]]; then
              BASE_PATH="$A"; HEAD_PATH="$B"; TITLE="$B"
            fi

            echo "#### \`$TITLE\`" >> "$GITHUB_STEP_SUMMARY"

            BASE_RAW="$(mkfile base_raw)"
            HEAD_RAW="$(mkfile head_raw)"
            git show "$BASE:$BASE_PATH" 2>/dev/null > "$BASE_RAW" || true
            git show "$HEAD:$HEAD_PATH" 2>/dev/null > "$HEAD_RAW" || true

            BASE_NORM="$(mkfile base_json)"
            HEAD_NORM="$(mkfile head_json)"
            VALID_BASE=1; VALID_HEAD=1
            if ! jq -S . < "$BASE_RAW" > "$BASE_NORM" 2>/dev/null; then VALID_BASE=0; echo '{}' > "$BASE_NORM"; fi
            if ! jq -S . < "$HEAD_RAW" > "$HEAD_NORM" 2>/dev/null; then VALID_HEAD=0; echo '{}' > "$HEAD_NORM"; fi

            NORM_DIFF="$(mkfile norm_diff)"
            if ! diff -u --label "$TITLE (base)" --label "$TITLE (head)" "$BASE_NORM" "$HEAD_NORM" > "$NORM_DIFF"; then
              echo '```diff' >> "$GITHUB_STEP_SUMMARY"
              truncate_or_all "$NORM_DIFF" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            else
              [[ $VALID_BASE -eq 0 || $VALID_HEAD -eq 0 ]] && echo "_Note: one of the versions is not valid JSON — raw diff only._" >> "$GITHUB_STEP_SUMMARY"
              echo "_No structural changes (after normalization)_" >> "$GITHUB_STEP_SUMMARY"
              echo >> "$GITHUB_STEP_SUMMARY"

              RAW_DIFF="$(mkfile raw_diff)"
              diff -u --label "$TITLE (base)" --label "$TITLE (head)" "$BASE_RAW" "$HEAD_RAW" > "$RAW_DIFF" || true
              echo "_Showing raw textual diff (formatting/whitespace changes may appear)_" >> "$GITHUB_STEP_SUMMARY"
              echo '```diff' >> "$GITHUB_STEP_SUMMARY"
              truncate_or_all "$RAW_DIFF" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            fi

            echo >> "$GITHUB_STEP_SUMMARY"
          done

          cat "$GITHUB_STEP_SUMMARY" > report.md

      - name: Ensure report exists
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          ls -l report.md || true
          test -s report.md || (echo "report.md is missing or empty" && exit 1)

      - name: Comment PR with report
        if: ${{ github.event_name == 'pull_request' }}
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: "Schema Changes Report"
          recreate: true
          path: report.md